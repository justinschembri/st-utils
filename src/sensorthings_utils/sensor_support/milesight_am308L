# standard
import os
from typing import Dict, List, Any
import logging
# external

# internal
from .frost import filter_query, make_frost_object, find_datastream_url 
from .sensor_things.core import Observation

# environment setup
CONTAINER_ENVIRONMENT = True if os.getenv("CONTAINER_ENVIRONMENT") else False
logger = logging.getLogger(__name__)

# consntants
EXPECTED_KEYS = [
        "sensor_name",
        "phenomenon_time",
        "observations"
        ] 

def _filter(
        payload: Dict,
        exclude: List[str] = ['']
    ) -> Dict[str, Any]:
    """
    Return parsed Milesight payload, keeping only relevant SensorThings data.
    
    Returns a dict with keys: `sensor_name`, `phenomenon_time`,
    `observations`.

    """
    data = {}
    identifiers = payload.get("identifiers")
    if identifiers is None:
        raise ValueError("No payload identifiers found.")
    if len(identifiers) != 1 or not isinstance(identifiers, list):
        raise ValueError(
                f"Expected payload identifiers to be List of len 1, got " + 
                f"{type(identifiers)} of len {len(identifiers)}"
                )
    try:
        data["sensor_name"] = payload["identifiers"][0]["device_ids"]["dev_eui"]
        data["phenomenon_time"] = payload["data"]["uplink_message"]["rx_metadata"][0]["time"]
        data["observations"] = payload["data"]["uplink_message"]["decoded_payload"]
        if data["sensor_name"] in exclude:
            return {}
    except KeyError as e:
        logger.critical(f"An invalid Milesight Payload was passed! Error: {e}")
        return {}
    return data


def _transform(data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Return transformed observations.

    :param data: Raw data from Milesight sensor.
    :type data:
    :return:
    :rtype:
    """
    ...
    MILESIGHT_TO_DATASTREAM_MAP = {
        "battery": "battery_level",
        "co2": "co2",
        "humidity": "humidity",
        "light_level": "light_level",
        "pir": "passive_infrared",
        "pm10": "particulate_matter_10",
        "pm2_5": "particulate_matter_2_5",
        "pressure": "gauge_pressure",
        "temperature": "temperature_indoor",
        "tvoc": "total_volatile_organic_compounds",
    }

    for key in EXPECTED_KEYS:
        if key not in data: raise ValueError(f"Missing key {key}.")

    transformed_observations = {
            transformed_key:data["observations"][key] for key, transformed_key in 
            MILESIGHT_TO_DATASTREAM_MAP.items()
            }
    transformed_data = {}
    transformed_data["observations"] = transformed_observations
    for metadata in ["sensor_name", "phenomenon_time"]:
        transformed_data[metadata] = data[metadata]
    return transformed_data

def frost_upload(
        raw_payload: Dict[str, Any],
        exclude: List[str] = [""],
    ) -> None:
    """Filter, transform and push Milesight AM3081 package to the FROST server."""
    transformed_payload = _transform(_filter(raw_payload, exclude))
    sensor_name = transformed_payload["sensor_name"]
    phenomenon_time = transformed_payload["phenomenon_time"]
    observations = transformed_payload["observations"] #type: Dict[str, Any]
    for datastream_name, result in observations.items():
        push_link = find_datastream_url(
                sensor_name, datastream_name, CONTAINER_ENVIRONMENT
                )
        observation = Observation(
            result=result,
            phenomenonTime=phenomenon_time,
        )
        try:
            make_frost_object(observation, push_link)
        except Exception as e:
            logger.critical(
                    f"Failure adding observation/s for {sensor_name}. Has the datastream been set up? Error: {e}"
            )
    return None
